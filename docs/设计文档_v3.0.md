# 软著材料生成系统开发计划 v3.0

## 背景与目标

开发一个基于Web的软著材料自动生成系统，用户输入软著名称和项目描述后，系统自动生成符合中国版权保护中心标准格式的：
1. 源代码文档（包含格式化的代码、行号、页眉页脚）
2. 操作手册（包含目录、自动生成的真实页面截图、模板化内容）
3. 申请表（辅助用户填写软著申请，基于Word模板自动填充）

三份文档均为Word格式（.docx），可直接用于软著申请。

### v3.0 相比 v2.0 的核心变化

| 变更项 | v2.0 | v3.0 |
|--------|------|------|
| 异步处理 | Celery + Redis（重量级） | ThreadPoolExecutor + 内存任务管理（轻量级） |
| 技术栈选项 | 十几种组合（维护成本高） | 首期3种核心技术栈，预留扩展机制 |
| 代码生成策略 | 纯AI生成 + code_expander补行数 | AI生成核心代码 + 预置代码模板混合填充 |
| 代码验证 | 多语言语法校验（复杂） | 行数统计 + 基本格式检查（务实） |
| 截图方案 | 统一1280x720视口 | 按项目类型适配视口和UI风格 |
| 申请表填充 | 直接python-docx替换 | 先POC验证 + 纯文本占位符替换 + 不可自动填充字段标注提示 |
| 错误处理 | 未设计 | 完整的重试、降级、断点恢复机制 |
| 任务持久化 | 无（纯内存） | JSON文件持久化任务状态 |
| 项目类型 | Web/桌面/移动/API四类 | 首期仅Web应用（最常见场景） |

### 设计原则

1. **最小可行方案优先**：先跑通一个完整流程，再逐步扩展
2. **轻量级部署**：本地开发只需启动Flask + Vue两个进程，无外部依赖
3. **渐进式扩展**：技术栈、项目类型通过配置文件扩展，不改核心代码
4. **容错优先**：每个步骤都有失败处理和降级策略

## 技术栈

- **后端框架**: Flask (Python) + Flask-CORS
- **前端框架**: Vue3 + Vite + Vue Router + Pinia + Element Plus + Axios
- **Word文档处理**: python-docx
- **AI集成**: 国产大模型（智谱AI GLM-4 为默认，可配置切换通义千问）
- **HTML页面生成**: Jinja2 模板引擎
- **页面截图**: Playwright (Python版，无头Chromium)
- **代码格式化**: Pygments (语法高亮)
- **异步处理**: concurrent.futures.ThreadPoolExecutor（线程池）
- **任务状态存储**: JSON文件持久化 + 内存缓存
- **进度推送**: SSE (Server-Sent Events)
- **文件存储**: 本地文件系统

> 相比v2.0，移除了 Celery、Redis、Flask-RESTful 三个重量级依赖。

## 首期支持的技术栈（3种）

v3.0 首期聚焦最常见的 Web 应用场景，支持以下3种技术栈：

| 技术栈标识 | 前端 | 后端 | 适用场景 |
|-----------|------|------|---------|
| `springboot_vue` | Vue3 + Element Plus | SpringBoot + MyBatis | Java系企业管理系统 |
| `flask_vue` | Vue3 + Element Plus | Flask + SQLAlchemy | Python系Web应用 |
| `django_vue` | Vue3 + Element Plus | Django + DRF | Python系中大型项目 |

扩展机制：新增技术栈只需在 `tech_stacks/` 目录下添加配置文件和提示词模板，无需修改核心代码。

```python
# tech_stacks/springboot_vue.yaml 示例
id: springboot_vue
name: "SpringBoot + Vue3"
languages: "Java、JavaScript、HTML、CSS"
dev_tools: "IntelliJ IDEA 2023、Maven 3.8、VS Code"
runtime: "JDK 1.8、MySQL 5.7、Apache Tomcat 9.0、Node.js 18"
os: "Windows 10 / CentOS 7.6"
frontend_framework: "Vue3 + Element Plus"
backend_framework: "SpringBoot 2.7"
# 代码模板目录
code_templates_dir: "code_templates/springboot_vue/"
# 提示词模板
prompt_template: "prompts/springboot_vue.txt"
```

> 后续扩展桌面应用、移动应用等项目类型时，需要同步新增对应的HTML截图模板和视口配置，工作量较大，建议作为v4.0规划。

## 核心功能模块

### 1. Web界面模块（Vue3 SPA）

前后端分离架构，Vue3作为系统本身的前端框架。

#### 1.1 首页 - 输入表单（HomeView.vue）

- 用户输入表单：
  - 软著名称（必填）
  - 项目简单描述（一句话，必填）
  - 技术栈选择（下拉选择，3个选项）
    - SpringBoot + Vue3
    - Flask + Vue3
    - Django + Vue3
  - 目标代码行数（默认5000行，范围3000-8000，滑块选择）
  - 开发完成日期（用于申请表，默认当前日期）
- 表单验证（Element Plus表单校验）
- 提交后跳转到进度页

> 相比v2.0，移除了"项目类型"选择（首期只做Web应用），简化了技术栈选项。

#### 1.2 进度页（ProgressView.vue）

- 6步生成进度指示器（StepIndicator组件）
- 当前步骤详细进度（ProgressTracker组件）
- SSE实时日志输出（LogPanel组件）
- 支持取消任务
- 页面顶部提示："生成过程约需3-8分钟，请勿关闭页面"
- 浏览器刷新后可恢复进度（通过taskId从后端重新获取状态）

#### 1.3 结果页（ResultView.vue）

- 3个文档卡片（DocumentCard组件）：源码文档、操作手册、申请表
- 单独下载 / 一键下载ZIP包
- 申请表卡片上标注提示："部分字段需手动补充，已用黄色高亮标记"

#### 1.4 Vue3组件结构

```
src/
├── main.js                     # Vue入口
├── App.vue                     # 根组件
├── router/
│   └── index.js                # 路由：/ → /progress/:taskId → /result/:taskId
├── stores/
│   └── generate.js             # Pinia状态管理（任务状态、进度）
├── api/
│   └── index.js                # Axios封装 + API调用
├── views/
│   ├── HomeView.vue            # 首页表单
│   ├── ProgressView.vue        # 生成进度
│   └── ResultView.vue          # 结果下载
├── components/
│   ├── ProjectForm.vue         # 项目信息表单（含技术栈选择）
│   ├── ProgressTracker.vue     # 进度追踪
│   ├── LogPanel.vue            # 实时日志面板
│   ├── DocumentCard.vue        # 文档卡片
│   └── StepIndicator.vue       # 步骤指示器
└── assets/
    └── styles/
        └── main.scss
```

> 相比v2.0，移除了独立的 TechStackSelector 组件（选项少了，直接放在 ProjectForm 里），新增了 LogPanel 组件。

### 2. AI代码生成模块

v3.0 采用"AI生成核心代码 + 预置代码模板填充"的混合策略，解决纯AI生成时行数不可控、代码质量不稳定的问题。

#### 2.1 混合代码生成策略

```
用户输入 + feature_list + 技术栈
         │
         ▼
┌─────────────────────────┐
│  第一层：预置代码模板     │  ← 项目骨架、配置文件、工具类（约40%行数）
│  code_templates/ 目录    │     确定性强，质量可控
└────────────┬────────────┘
             │
             ▼
┌─────────────────────────┐
│  第二层：AI生成业务代码   │  ← 按feature_list逐功能生成（约60%行数）
│  核心业务逻辑、API接口    │     每个功能独立生成，降低单次生成压力
└────────────┬────────────┘
             │
             ▼
┌─────────────────────────┐
│  第三层：行数调节         │  ← 如果总行数不足，从模板库补充注释、
│  补充注释/文档字符串      │     文档字符串、配置变体（非低质量填充）
└─────────────────────────┘
```

#### 2.2 预置代码模板（code_templates/）

每种技术栈预置一套项目骨架模板，包含：

```
code_templates/
├── springboot_vue/
│   ├── backend/
│   │   ├── pom.xml                          # Maven配置
│   │   ├── Application.java                 # 启动类
│   │   ├── config/SecurityConfig.java       # 安全配置
│   │   ├── config/CorsConfig.java           # 跨域配置
│   │   ├── config/MyBatisConfig.java        # MyBatis配置
│   │   ├── common/Result.java               # 统一返回结果
│   │   ├── common/PageResult.java           # 分页结果
│   │   ├── utils/JwtUtil.java               # JWT工具类
│   │   └── utils/DateUtil.java              # 日期工具类
│   └── frontend/
│       ├── package.json
│       ├── vite.config.js
│       ├── src/main.js
│       ├── src/router/index.js
│       ├── src/utils/request.js             # Axios封装
│       └── src/utils/auth.js                # 认证工具
├── flask_vue/
│   └── ...（类似结构）
└── django_vue/
    └── ...（类似结构）
```

模板中使用 `{{software_name}}`、`{{feature_name}}` 等占位符，生成时由 Jinja2 渲染替换。

#### 2.3 AI业务代码生成

- **提示词构建器** (`prompt_builder.py`)：
  - 按 feature_list 逐功能构建提示词
  - 每次AI调用只生成一个功能模块的代码（降低单次生成压力，提高成功率）
  - 提示词中包含已生成代码的文件列表（避免重复）
  - 明确指定文件命名规范和代码结构

- **AI客户端** (`ai_client.py`)：
  - 默认使用智谱AI GLM-4，可配置切换通义千问
  - 适配器模式：`ZhipuAdapter`、`TongyiAdapter`
  - 支持流式响应
  - 内置重试机制（最多3次，指数退避）
  - 单次调用超时：60秒
  - **降级策略**：如果主模型连续失败3次，自动切换到备用模型（需配置）

```python
class AIClient:
    def __init__(self, config):
        self.primary = self._create_adapter(config.primary_provider)
        self.fallback = self._create_adapter(config.fallback_provider) if config.fallback_provider else None

    def generate(self, prompt: str, max_retries=3) -> str:
        # 先尝试主模型
        try:
            return self._call_with_retry(self.primary, prompt, max_retries)
        except AIClientError:
            if self.fallback:
                logger.warning("主模型失败，切换到备用模型")
                return self._call_with_retry(self.fallback, prompt, max_retries)
            raise
```

#### 2.4 代码检查器（简化版）

v3.0 将 v2.0 的 `code_validator.py` 和 `code_expander.py` 合并简化为 `code_checker.py`：

```python
class CodeChecker:
    """代码检查器 - 只做行数统计和基本格式检查，不做语法校验"""

    def check(self, generated_code: dict) -> CodeCheckResult:
        total_lines = 0
        file_stats = []
        for filepath, content in generated_code.items():
            lines = content.count('\n') + 1
            total_lines += lines
            file_stats.append({
                'path': filepath,
                'lines': lines,
                'language': self._detect_language(filepath),
                'has_content': len(content.strip()) > 0
            })

        return CodeCheckResult(
            total_lines=total_lines,
            file_count=len(generated_code),
            file_stats=file_stats,
            needs_expansion=total_lines < target_lines * 0.8,  # 不足目标80%才补充
            languages=list(set(s['language'] for s in file_stats))
        )
```

> 不做多语言语法校验（工作量大且意义有限），生成的代码本质上是"用于软著申请的示例代码"。

### 3. 源码文档生成模块

按照软著要求格式化源代码：
- 页面设置：A4纸张，上下边距2.54cm，左右边距3.17cm
- 页眉："{软著名称}源程序"，宋体小五号
- 页脚：页码（居中），"第X页 共Y页"
- 行号：每行代码前添加行号（右对齐，4位数字）
- 字体：代码使用Courier New 小四号
- 提取规则：前30页 + 后30页（共60页）
  - 如果总代码超过60页，取前30页和后30页
  - 如果总代码不足60页，则全部输出
- **一致性要求**：源码文档中的代码必须与操作手册中展示的功能页面对应

> 关于行数关系说明：假设目标行数5000行，每页约50行代码，共约100页。源码文档取前30页+后30页=60页≈3000行用于提交。剩余代码虽不在文档中展示，但在 generated_code 中完整保留，total_lines 统计的是全部代码行数（用于申请表填写）。

### 4. 操作手册生成模块

#### 4.1 截图生成流程

```
遍历 feature_list
    │
    ▼
[选择HTML模板] → login / dashboard / list / form / detail / chart
    │
    ▼
[AI生成页面内容] → 表单字段、表格列、菜单项、示例数据
    │
    ▼
[Jinja2渲染] → 完整HTML文件（内联CSS，不依赖外部资源）
    │
    ▼
[Playwright截图] → 无头Chromium，Web应用视口1280x800，保存PNG
    │                失败时使用占位图 + 警告日志
    ▼
[插入操作手册] → python-docx插入图片到对应章节
```

#### 4.2 HTML页面生成器 (`html_page_generator.py`)

- 根据 `feature.page_type` 选择基础HTML模板
- 可用模板类型（首期6种，均为Web管理系统风格）：
  - `login` - 登录/注册页面
  - `dashboard` - 仪表盘/首页（统计卡片+图表）
  - `list` - 数据列表页（表格+搜索+分页）
  - `form` - 表单页（新增/编辑）
  - `detail` - 详情页
  - `chart` - 图表统计页
- AI生成页面具体内容（字段名、菜单项、表格数据等）
- Jinja2渲染为完整HTML文件
- 设计原则：
  - 所有CSS内联，确保截图时样式完整
  - 统一UI风格（模拟Element Plus管理系统外观）
  - 包含侧边栏导航（菜单项从feature_list提取）、顶部标题栏、内容区域
  - 表单预填充示例数据，让截图更真实

#### 4.3 截图服务 (`screenshot_service.py`)

```python
class ScreenshotService:
    """Playwright截图服务，带完整错误处理"""

    # Web应用视口配置
    VIEWPORT = {"width": 1280, "height": 800}

    async def take_screenshots(self, html_files: dict) -> dict:
        """批量截图，复用浏览器实例"""
        results = {}
        browser = None
        try:
            browser = await self.playwright.chromium.launch(headless=True)
            context = await browser.new_context(viewport=self.VIEWPORT)

            for feature_name, html_path in html_files.items():
                try:
                    page = await context.new_page()
                    await page.goto(f"file://{html_path}", wait_until="networkidle", timeout=15000)
                    await page.wait_for_timeout(500)  # 额外等待渲染
                    screenshot_path = self._get_screenshot_path(feature_name)
                    await page.screenshot(path=screenshot_path, full_page=False)
                    results[feature_name] = screenshot_path
                    await page.close()
                except Exception as e:
                    logger.error(f"截图失败 [{feature_name}]: {e}")
                    # 降级：使用占位图
                    results[feature_name] = self._create_placeholder_image(feature_name)
            return results
        except Exception as e:
            logger.error(f"浏览器启动失败: {e}")
            # 全部降级为占位图
            return {name: self._create_placeholder_image(name) for name in html_files}
        finally:
            if browser:
                await browser.close()

    def _create_placeholder_image(self, feature_name: str) -> str:
        """生成带文字的灰色占位图"""
        # 使用Pillow生成简单的占位图片
        ...
```

#### 4.4 操作手册文档结构

- **封面页**：
  - 软著名称
  - 版本号（V1.0）
  - 编写日期

- **自动生成目录**（使用Word样式）

- **标准章节**：
  1. **引言**
     - 1.1 编写目的
     - 1.2 项目背景
     - 1.3 术语定义

  2. **运行环境**
     - 2.1 硬件环境
     - 2.2 软件环境（从技术栈配置文件自动读取）
     - 2.3 网络环境

  3. **安装与配置**
     - 3.1 安装步骤（从技术栈配置文件读取模板）
     - 3.2 配置说明
     - 3.3 启动方法

  4. **功能说明**（核心章节，遍历feature_list生成）
     - 4.1 功能概述
     - 4.2 功能模块详细说明
       - 4.2.1 {功能名称1}
         - AI生成的功能描述文字
         - **自动截图**（从HTML页面截取）
         - 操作步骤说明
       - 4.2.2 {功能名称2}
         - ...
       - （遍历所有feature生成）

  5. **注意事项**
     - 5.1 使用限制
     - 5.2 常见问题

- **格式规范**：标题使用黑体，正文使用宋体，行间距1.5倍
- **图片标题**：每张截图下方添加居中图注（如"图1 用户登录界面"）

### 5. 申请表生成模块

#### 5.1 可行性说明

软著申请表Word模板通常包含复杂的表格、复选框、合并单元格。python-docx 处理这类格式有局限性。v3.0 采用务实策略：

- **可自动填充的字段**：纯文本单元格中的占位符替换（如软件名称、版本号、日期等）
- **不可自动填充的字段**：复选框勾选、复杂合并单元格内容 → 用黄色高亮标记 + 文字提示，由用户手动补充
- **开发前必须做POC验证**：拿 `template/基于SpringBoot的鱼缸控制系统_申请表.docx` 做一次 python-docx 读写测试，确认哪些字段能自动填、哪些不能

#### 5.2 填充策略

```python
class ApplicationDocGenerator:
    """申请表生成器 - 纯文本占位符替换 + 不可填充字段标注"""

    # 可自动填充的字段（纯文本替换）
    AUTO_FILL_FIELDS = {
        "{{软件全称}}": lambda ctx: ctx.software_name,
        "{{简称}}": lambda ctx: ctx.short_name,
        "{{版本号}}": lambda ctx: "V1.0",
        "{{开发完成日期}}": lambda ctx: ctx.completion_date,
        "{{源程序量}}": lambda ctx: str(ctx.total_lines),
        "{{编程语言}}": lambda ctx: ctx.tech_config['languages'],
        "{{主要功能}}": lambda ctx: ctx.feature_summary,
        "{{硬件环境}}": lambda ctx: "PC服务器/云服务器，CPU 4核以上，内存8GB以上",
        "{{运行环境}}": lambda ctx: ctx.tech_config['os'],
        "{{软件环境}}": lambda ctx: ctx.tech_config['runtime'],
        "{{开发工具}}": lambda ctx: ctx.tech_config['dev_tools'],
    }

    # 需要用户手动填写的字段（黄色高亮标记）
    MANUAL_FIELDS = [
        "著作权人",
        "证件号码",
        "联系地址",
        "联系电话",
        "权利取得方式",    # 复选框，python-docx难以处理
        "权利范围",        # 复选框
    ]
```

#### 5.3 技术栈环境信息

从技术栈配置文件（YAML）中读取，不再硬编码在代码里：

```yaml
# tech_stacks/springboot_vue.yaml
environment:
  languages: "Java、JavaScript、HTML、CSS"
  dev_tools: "IntelliJ IDEA 2023、Maven 3.8、VS Code"
  runtime: "JDK 1.8、MySQL 5.7、Apache Tomcat 9.0、Node.js 18"
  os: "Windows 10 / CentOS 7.6"
  hardware: "PC服务器，CPU 4核以上，内存8GB以上，硬盘100GB以上"
```

### 6. 文档下载模块

- 生成三个Word文档：
  - `{软著名称}_源程序.docx`
  - `{软著名称}_操作手册.docx`
  - `{软著名称}_申请表.docx`
- 打包为ZIP文件供用户下载
- 支持单独下载每个文档
- 文件保留24小时后自动清理（定时清理脚本）

## 生成编排器与一致性保证

### 7. 生成编排器 (`orchestrator.py`)

编排器是系统的核心协调模块，维护 `ProjectContext` 数据结构，贯穿整个生成流程。

#### 7.1 ProjectContext 数据结构

```python
@dataclass
class Feature:
    """功能模块描述，一致性的最小单元"""
    name: str               # 功能名称（如"用户登录"）
    description: str        # 功能描述
    page_type: str          # 页面类型（login/dashboard/list/form/detail/chart）
    manual_section: str     # 对应操作手册章节编号（如"4.2.1"）
    code_files: list[str] = field(default_factory=list)   # 对应的源代码文件列表
    html_path: str = ""     # HTML页面路径（生成后填充）
    screenshot_path: str = ""  # 截图文件路径（生成后填充）
    operation_steps: str = ""  # 操作步骤说明（AI生成）

@dataclass
class ProjectContext:
    """贯穿整个生成流程的上下文对象，支持JSON序列化以持久化"""

    # 用户输入
    software_name: str          # 软著名称
    short_name: str             # 简称（自动从全称提取）
    description: str            # 项目描述
    tech_stack_id: str          # 技术栈标识（如"springboot_vue"）
    tech_config: dict           # 技术栈配置（从YAML加载）
    target_lines: int           # 目标代码行数
    completion_date: str        # 开发完成日期

    # AI生成的功能清单（一致性的核心锚点，步骤1确定后不可变）
    feature_list: list[Feature] = field(default_factory=list)

    # 生成产物
    generated_code: dict = field(default_factory=dict)        # {文件路径: 代码内容}
    generated_html_pages: dict = field(default_factory=dict)  # {功能名: HTML文件路径}
    screenshots: dict = field(default_factory=dict)           # {功能名: 截图文件路径}

    # 统计信息（用于申请表）
    total_lines: int = 0
    feature_summary: str = ""   # 功能摘要（从feature_list生成）

    def to_json(self) -> str:
        """序列化为JSON，用于任务状态持久化"""
        ...

    @classmethod
    def from_json(cls, json_str: str) -> 'ProjectContext':
        """从JSON反序列化"""
        ...
```

#### 7.2 六步生成流程

```
用户输入 → [步骤1] AI生成功能清单 (feature_list)
              │
              ▼
         [步骤2] 混合生成源代码（模板骨架 + AI业务代码）
              │
              ▼
         [步骤3] 生成HTML静态页面（按feature_list遍历）
              │
              ▼
         [步骤4] Playwright批量截图（失败降级为占位图）
              │
              ▼
         [步骤5] 生成3个Word文档
              │    ├→ 源码文档 ← generated_code
              │    ├→ 操作手册 ← feature_list + screenshots
              │    └→ 申请表   ← 模板填充 + 手动字段标注
              ▼
         [步骤6] 打包ZIP → 返回下载链接
```

各步骤详细说明：

| 步骤 | 名称 | 输入 | 输出 | 预估耗时 | 失败处理 |
|------|------|------|------|----------|----------|
| 1 | 生成功能清单 | 软著名称+描述+技术栈 | feature_list (6-10个功能) | 10-20秒 | 重试3次，失败则终止 |
| 2 | 混合生成代码 | feature_list + 代码模板 | generated_code | 2-5分钟 | 单功能失败跳过，记录警告 |
| 3 | 生成HTML页面 | feature_list + 页面模板 | HTML文件 | 30-60秒 | 单页面失败跳过 |
| 4 | 页面截图 | HTML文件列表 | PNG截图 | 10-30秒 | 失败使用占位图 |
| 5 | 生成文档 | 所有产物 | 3个.docx文件 | 20-40秒 | 单文档失败不影响其他 |
| 6 | 打包下载 | .docx文件 | ZIP文件 | <5秒 | - |

#### 7.3 断点恢复机制

每个步骤完成后，将 ProjectContext 序列化保存到 JSON 文件。如果生成过程中断（进程崩溃、用户刷新页面等），可以从最后完成的步骤恢复：

```python
class Orchestrator:
    def run(self, task_id: str, context: ProjectContext):
        """执行生成流程，支持断点恢复"""
        checkpoint = self._load_checkpoint(task_id)
        start_step = checkpoint.get('completed_step', 0) + 1

        steps = [
            (1, "生成功能清单", self._step1_generate_features),
            (2, "生成源代码",   self._step2_generate_code),
            (3, "生成HTML页面", self._step3_generate_html),
            (4, "页面截图",     self._step4_take_screenshots),
            (5, "生成文档",     self._step5_generate_docs),
            (6, "打包下载",     self._step6_package),
        ]

        for step_num, step_name, step_func in steps:
            if step_num < start_step:
                continue  # 跳过已完成的步骤
            try:
                self._update_progress(task_id, step_num, step_name, "processing")
                step_func(context)
                self._save_checkpoint(task_id, step_num, context)
            except StepFatalError as e:
                self._update_progress(task_id, step_num, step_name, "failed", str(e))
                raise
            except StepWarningError as e:
                logger.warning(f"步骤{step_num}部分失败: {e}")
                self._save_checkpoint(task_id, step_num, context)
                # 继续执行下一步
```

### 8. 三文档一致性保证机制

`feature_list` 作为"单一事实来源"（Single Source of Truth），三个文档都从同一个 feature_list 派生内容：

```
                    ┌─────────────────┐
                    │  feature_list   │  ← 步骤1确定，后续不可变
                    │  (功能清单)      │
                    └────────┬────────┘
                             │
              ┌──────────────┼──────────────┐
              ▼              ▼              ▼
     ┌────────────┐  ┌────────────┐  ┌────────────┐
     │  源码文档   │  │  操作手册   │  │  申请表     │
     │            │  │            │  │            │
     │ 包含每个    │  │ 每个功能有  │  │ 主要功能   │
     │ 功能的前后  │  │ 描述+截图+  │  │ 描述来自   │
     │ 端代码     │  │ 操作步骤    │  │ feature    │
     └────────────┘  └────────────┘  └────────────┘
```

#### 8.1 一致性校验器

在步骤5生成文档前，运行一致性校验。校验不通过不阻断流程，而是记录警告并在结果页提示用户：

```python
class ConsistencyChecker:
    def check(self, context: ProjectContext) -> ConsistencyReport:
        warnings = []
        errors = []

        for feature in context.feature_list:
            # 检查1: 每个功能都有对应的代码文件
            if not feature.code_files:
                warnings.append(f"功能'{feature.name}'缺少对应代码，操作手册中仍会包含该功能描述")

            # 检查2: 需要截图的功能都有截图（含占位图）
            if feature.page_type and not feature.screenshot_path:
                warnings.append(f"功能'{feature.name}'缺少截图")

            # 检查3: 截图是否为占位图
            if feature.screenshot_path and "placeholder" in feature.screenshot_path:
                warnings.append(f"功能'{feature.name}'使用了占位截图，建议手动替换")

        # 检查4: 总代码行数是否达标
        if context.total_lines < context.target_lines * 0.6:
            errors.append(f"代码行数({context.total_lines})严重不足目标({context.target_lines})")

        return ConsistencyReport(warnings=warnings, errors=errors)
```

## 任务管理与异步处理

### 9. 轻量级任务管理器 (`task_manager.py`)

替代 v2.0 的 Celery + Redis，使用线程池 + JSON文件持久化：

```python
import uuid
import json
from concurrent.futures import ThreadPoolExecutor
from pathlib import Path

class TaskManager:
    """轻量级任务管理器 - 线程池执行 + JSON文件持久化"""

    def __init__(self, max_workers=2, data_dir="./data/tasks"):
        self.executor = ThreadPoolExecutor(max_workers=max_workers)
        self.data_dir = Path(data_dir)
        self.data_dir.mkdir(parents=True, exist_ok=True)
        # 内存缓存（加速读取，启动时从文件恢复）
        self._cache: dict[str, dict] = {}
        self._load_from_disk()

    def submit_task(self, context: ProjectContext) -> str:
        """提交生成任务，返回task_id"""
        task_id = str(uuid.uuid4())[:8]
        task_state = {
            "task_id": task_id,
            "status": "pending",
            "current_step": 0,
            "step_name": "",
            "progress": 0,
            "message": "任务已创建，等待执行...",
            "created_at": datetime.now().isoformat(),
            "context": context.to_dict(),
            "warnings": [],
            "output_files": {}
        }
        self._save_state(task_id, task_state)

        # 提交到线程池执行
        future = self.executor.submit(self._run_task, task_id, context)
        future.add_done_callback(lambda f: self._on_task_done(task_id, f))
        return task_id

    def get_task_state(self, task_id: str) -> dict | None:
        """获取任务状态（优先内存缓存，fallback到文件）"""
        if task_id in self._cache:
            return self._cache[task_id]
        return self._load_state(task_id)

    def update_progress(self, task_id: str, step: int, name: str, progress: int, message: str):
        """更新任务进度（同时更新内存和文件）"""
        state = self.get_task_state(task_id)
        state.update({
            "status": "processing",
            "current_step": step,
            "step_name": name,
            "progress": progress,
            "message": message
        })
        self._save_state(task_id, state)

    def _save_state(self, task_id: str, state: dict):
        """持久化到JSON文件 + 更新内存缓存"""
        self._cache[task_id] = state
        filepath = self.data_dir / f"{task_id}.json"
        filepath.write_text(json.dumps(state, ensure_ascii=False, indent=2))

    def _load_from_disk(self):
        """启动时从磁盘恢复任务状态"""
        for f in self.data_dir.glob("*.json"):
            try:
                state = json.loads(f.read_text())
                self._cache[state["task_id"]] = state
            except Exception:
                pass
```

> 为什么不用 Celery + Redis？本系统是工具型应用，并发量低（通常单用户使用），ThreadPoolExecutor 完全够用。部署时只需启动 Flask 和 Vue 两个进程，无需额外安装 Redis。

## 后端API设计

### 10. RESTful API 接口

```
POST   /api/generate                    # 提交生成任务
  请求体: {
    software_name: "xxx管理系统",
    description: "一个用于xxx的管理系统",
    tech_stack: "springboot_vue",
    target_lines: 5000,
    completion_date: "2026-01-15"
  }
  响应: { task_id: "a1b2c3d4" }

GET    /api/task/<task_id>              # 查询任务状态
  响应: {
    task_id: "a1b2c3d4",
    status: "processing" | "completed" | "failed",
    current_step: 3,
    step_name: "生成HTML页面",
    progress: 45,
    message: "正在生成用户登录页面...",
    warnings: ["功能'数据统计'使用了占位截图"],
    output_files: {}
  }

GET    /api/task/<task_id>/stream       # SSE实时进度推送
  响应: text/event-stream

GET    /api/download/<task_id>/source       # 下载源码文档
GET    /api/download/<task_id>/manual       # 下载操作手册
GET    /api/download/<task_id>/application  # 下载申请表
GET    /api/download/<task_id>/all          # 下载ZIP包（3个文档）

GET    /api/tech-stacks                     # 获取可用技术栈列表（前端下拉选项）
```

### SSE进度推送

```python
@app.route('/api/task/<task_id>/stream')
def task_stream(task_id):
    def event_stream():
        while True:
            state = task_manager.get_task_state(task_id)
            if not state:
                yield f"data: {json.dumps({'error': '任务不存在'})}\n\n"
                break
            yield f"data: {json.dumps(state)}\n\n"
            if state['status'] in ('completed', 'failed'):
                break
            time.sleep(1)
    return Response(event_stream(), mimetype='text/event-stream',
                    headers={'Cache-Control': 'no-cache', 'X-Accel-Buffering': 'no'})
```

```javascript
// 前端SSE接收（ProgressView.vue）
const eventSource = new EventSource(`/api/task/${taskId}/stream`)
eventSource.onmessage = (event) => {
  const data = JSON.parse(event.data)
  store.updateProgress(data)
  if (data.status === 'completed' || data.status === 'failed') {
    eventSource.close()
  }
}
eventSource.onerror = () => {
  // SSE断开后降级为轮询
  eventSource.close()
  startPolling(taskId)
}
```

> SSE断开时自动降级为轮询，确保进度不丢失。

## 错误处理与降级策略

### 11. 全局错误处理设计

v3.0 对每个环节都设计了明确的失败处理策略，避免单点故障导致整个流程失败。

#### 11.1 错误分级

```python
class StepFatalError(Exception):
    """致命错误 - 无法继续，终止整个流程"""
    pass

class StepWarningError(Exception):
    """警告错误 - 当前步骤部分失败，但可以继续后续步骤"""
    pass
```

#### 11.2 各环节降级策略

| 环节 | 可能的失败 | 降级策略 |
|------|-----------|---------|
| AI生成功能清单 | API超时/返回异常 | 重试3次（指数退避），全部失败则终止任务 |
| AI生成业务代码 | 单功能生成失败 | 跳过该功能，用预置模板中的空壳文件替代，记录警告 |
| AI生成业务代码 | 主模型连续失败 | 自动切换备用模型（如智谱→通义） |
| 代码行数不足 | 总行数 < 目标80% | 从模板库补充工具类、配置文件、注释 |
| HTML页面生成 | AI返回格式异常 | 使用对应page_type的默认模板（无AI定制内容） |
| Playwright截图 | Chromium启动失败 | 全部使用Pillow生成的占位图 |
| Playwright截图 | 单页面渲染超时 | 该页面使用占位图，其他继续 |
| 申请表填充 | 模板格式不兼容 | 跳过不可填充字段，黄色高亮标记提示用户 |
| 文档生成 | python-docx异常 | 单文档失败不影响其他两个文档生成 |

#### 11.3 用户可见的错误反馈

- 进度页实时显示警告信息（黄色提示条）
- 结果页汇总所有警告：
  - "以下功能使用了占位截图，建议手动替换真实截图"
  - "申请表中以下字段需要手动填写（已黄色高亮标记）"
  - "代码行数为 XXX 行，未达到目标 XXX 行"

## 项目结构

```
kinghy-bot/
├── server/                             # 后端（Flask）
│   ├── app.py                          # Flask主应用 + CORS配置
│   ├── config.py                       # 配置文件（API密钥、模型选择等）
│   ├── requirements.txt                # Python依赖
│   ├── .env.example                    # 环境变量示例
│   ├── api/                            # API路由
│   │   ├── __init__.py
│   │   ├── generate.py                 # 生成任务API
│   │   ├── task.py                     # 任务状态API + SSE
│   │   └── download.py                 # 文件下载API
│   ├── ai/                             # AI集成模块
│   │   ├── __init__.py
│   │   ├── ai_client.py               # AI API客户端（适配器模式）
│   │   ├── adapters/                   # 模型适配器
│   │   │   ├── __init__.py
│   │   │   ├── zhipu_adapter.py       # 智谱AI适配器
│   │   │   └── tongyi_adapter.py      # 通义千问适配器
│   │   ├── prompt_builder.py           # 提示词构建器
│   │   └── prompts/                    # 提示词模板目录
│   │       ├── feature_gen.txt         # 功能清单生成提示词
│   │       ├── code_gen.txt            # 代码生成提示词
│   │       ├── manual_gen.txt          # 操作手册内容提示词
│   │       └── page_gen.txt            # HTML页面生成提示词
│   ├── generators/                     # 生成器模块
│   │   ├── __init__.py
│   │   ├── orchestrator.py             # 生成编排器（核心协调）
│   │   ├── code_generator.py           # 混合代码生成器（模板+AI）
│   │   ├── code_checker.py             # 代码检查器（行数统计+格式检查）
│   │   ├── source_doc_generator.py     # 源码文档生成器
│   │   ├── manual_doc_generator.py     # 操作手册生成器
│   │   ├── application_doc_generator.py # 申请表生成器
│   │   ├── html_page_generator.py      # HTML页面生成器
│   │   ├── screenshot_service.py       # Playwright截图服务
│   │   └── consistency_checker.py      # 一致性校验器
│   ├── task/                           # 任务管理
│   │   ├── __init__.py
│   │   └── task_manager.py             # 轻量级任务管理器（线程池+JSON持久化）
│   ├── utils/                          # 工具函数
│   │   ├── __init__.py
│   │   ├── code_formatter.py           # 代码格式化（Pygments）
│   │   ├── docx_helper.py             # Word文档辅助函数
│   │   └── file_manager.py            # 文件管理（清理过期文件等）
│   ├── tech_stacks/                    # 技术栈配置（YAML，可扩展）
│   │   ├── springboot_vue.yaml
│   │   ├── flask_vue.yaml
│   │   └── django_vue.yaml
│   ├── code_templates/                 # 预置代码模板
│   │   ├── springboot_vue/
│   │   │   ├── backend/               # Java后端骨架
│   │   │   └── frontend/              # Vue前端骨架
│   │   ├── flask_vue/
│   │   │   ├── backend/
│   │   │   └── frontend/
│   │   └── django_vue/
│   │       ├── backend/
│   │       └── frontend/
│   ├── html_templates/                 # 截图用HTML页面模板
│   │   ├── base.html                   # 基础布局（侧边栏+顶栏+内容区）
│   │   ├── login.html                  # 登录页模板
│   │   ├── dashboard.html              # 仪表盘模板
│   │   ├── list.html                   # 列表页模板
│   │   ├── form.html                   # 表单页模板
│   │   ├── detail.html                 # 详情页模板
│   │   └── chart.html                  # 图表统计页模板
│   ├── template/                       # Word文档模板
│   │   └── 申请表_模板.docx
│   ├── data/                           # 运行时数据
│   │   ├── tasks/                      # 任务状态JSON文件
│   │   └── .gitkeep
│   ├── output/                         # 生成的文档输出目录
│   │   └── .gitkeep
│   ├── screenshots/                    # 截图临时存储
│   │   └── .gitkeep
│   └── tests/                          # 测试文件
│       ├── test_ai_client.py
│       ├── test_generators.py
│       ├── test_screenshot.py
│       ├── test_consistency.py
│       └── test_application_doc_poc.py # 申请表POC验证测试
│
├── client/                             # 前端（Vue3 + Vite）
│   ├── package.json
│   ├── vite.config.js                  # Vite配置（含API代理）
│   ├── index.html
│   ├── src/
│   │   ├── main.js
│   │   ├── App.vue
│   │   ├── router/
│   │   │   └── index.js
│   │   ├── stores/
│   │   │   └── generate.js
│   │   ├── api/
│   │   │   └── index.js
│   │   ├── views/
│   │   │   ├── HomeView.vue
│   │   │   ├── ProgressView.vue
│   │   │   └── ResultView.vue
│   │   ├── components/
│   │   │   ├── ProjectForm.vue
│   │   │   ├── ProgressTracker.vue
│   │   │   ├── LogPanel.vue
│   │   │   ├── DocumentCard.vue
│   │   │   └── StepIndicator.vue
│   │   └── assets/
│   │       └── styles/
│   │           └── main.scss
│   └── public/
│       └── favicon.ico
│
├── docs/                               # 项目文档
│   ├── 设计文档_v1.0.md
│   ├── 设计文档_v2.0.md
│   └── 设计文档_v3.0.md
├── template/                           # 参考模板（只读，用于对照格式）
│   ├── 基于SpringBoot的鱼缸控制系统_申请表.docx
│   ├── 基于SpringBoot的鱼缸控制系统_操作手册.docx
│   └── 基于SpringBoot的鱼缸控制系统_代码文档.docx
└── README.md
```

> 相比v2.0的变化：新增 `tech_stacks/`（YAML配置）、`code_templates/`（预置代码模板）、`data/tasks/`（任务持久化）、`ai/adapters/`（模型适配器）。移除了 `code_expander.py`（合并到 code_generator），移除了 `line_counter.py`（合并到 code_checker）。

## 依赖清单

### 后端 Python 依赖 (requirements.txt)

```
flask>=3.0
flask-cors>=4.0
python-docx>=1.1
Jinja2>=3.1
playwright>=1.40
Pygments>=2.17
python-dotenv>=1.0
requests>=2.31
PyYAML>=6.0
Pillow>=10.0
```

> 相比v2.0，移除了 celery、redis、flask-restful。新增 PyYAML（技术栈配置文件解析）、Pillow（占位图生成）。

### 前端 Node 依赖 (package.json)

```json
{
  "dependencies": {
    "vue": "^3.4",
    "vue-router": "^4.2",
    "pinia": "^2.1",
    "element-plus": "^2.5",
    "axios": "^1.6"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^5.0",
    "vite": "^5.0",
    "sass": "^1.69"
  }
}
```

## 开发与部署

### 本地开发

```bash
# 后端
cd server
pip install -r requirements.txt
playwright install chromium
cp .env.example .env  # 配置AI模型API密钥
python app.py         # 启动Flask，默认端口5000

# 前端（另开终端）
cd client
npm install
npm run dev           # 默认端口5173，Vite代理API到5000
```

> 只需两个终端，无需额外启动 Redis 或 Celery Worker。

### Vite API代理配置

```javascript
// vite.config.js
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

export default defineConfig({
  plugins: [vue()],
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:5000',
        changeOrigin: true
      }
    }
  }
})
```

### 环境变量 (.env)

```
# AI模型配置
AI_PRIMARY_PROVIDER=zhipu          # 主模型：zhipu / tongyi
AI_PRIMARY_API_KEY=your-api-key
AI_PRIMARY_MODEL=glm-4

# 备用模型（可选，主模型失败时自动切换）
AI_FALLBACK_PROVIDER=tongyi
AI_FALLBACK_API_KEY=your-fallback-key
AI_FALLBACK_MODEL=qwen-max

# 文件存储
OUTPUT_DIR=./output
SCREENSHOT_DIR=./screenshots
TASK_DATA_DIR=./data/tasks

# 任务配置
MAX_CONCURRENT_TASKS=2             # 最大并发任务数
FILE_RETENTION_HOURS=24            # 生成文件保留时长（小时）
```

## 开发计划与里程碑

### Phase 1：基础框架搭建（第1-2天）

- [ ] 初始化 Flask 后端项目结构
- [ ] 初始化 Vue3 + Vite 前端项目
- [ ] 实现前后端联通（API代理、CORS）
- [ ] 实现 TaskManager（线程池 + JSON持久化）
- [ ] 实现 SSE 进度推送
- [ ] 前端三个页面基础骨架（首页表单、进度页、结果页）

### Phase 2：申请表POC验证（第2天）

- [ ] 用 python-docx 读取参考模板 `基于SpringBoot的鱼缸控制系统_申请表.docx`
- [ ] 验证哪些字段可以自动填充、哪些不能
- [ ] 确定最终的申请表填充策略
- [ ] 编写 `test_application_doc_poc.py` 记录验证结果

### Phase 3：AI集成与代码生成（第3-5天）

- [ ] 实现 AI 客户端（智谱AI适配器）
- [ ] 实现提示词构建器
- [ ] 实现功能清单生成（步骤1）
- [ ] 准备 springboot_vue 预置代码模板
- [ ] 实现混合代码生成（步骤2）
- [ ] 实现代码检查器

### Phase 4：截图与文档生成（第6-8天）

- [ ] 编写6种HTML页面模板
- [ ] 实现 HTML 页面生成器（步骤3）
- [ ] 实现 Playwright 截图服务（步骤4）
- [ ] 实现源码文档生成器
- [ ] 实现操作手册生成器
- [ ] 实现申请表生成器
- [ ] 实现一致性校验器

### Phase 5：联调与完善（第9-10天）

- [ ] 编排器完整流程联调
- [ ] 前端进度展示完善
- [ ] 错误处理和降级策略验证
- [ ] 断点恢复测试
- [ ] 补充 flask_vue、django_vue 技术栈配置和模板

### Phase 6：测试与优化（第11-12天）

- [ ] 端到端测试（3种技术栈各生成一次）
- [ ] 生成文档质量检查（对照参考模板）
- [ ] 性能优化（截图批量处理、AI调用并行化）
- [ ] 文件清理定时任务
- [ ] README 编写
